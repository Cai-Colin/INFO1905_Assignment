package doublehashmap;

import java.util.ArrayList;
import java.util.List;

public class DoubleHashMap<K extends Comparable<K>, V>
{
	private HashMapNode<K, V>[] array;
	private int multiplier;
	private int modulus;
	private int secondaryModulus;
	private int collisions;
	private int probes;
	private int maxProbes;
	
	//Sentinel value that removed values are replaced with
	private HashMapNode<K, V> SENTINEL;
	{
		SENTINEL = new HashMapNode<K, V>(null, null);
	}
	
	// construct a DoubleHashMap with 4000 places and given hash parameters
	@SuppressWarnings("unchecked")
	public DoubleHashMap(int multiplier, int modulus, int secondaryModulus)
	{
		this.array = (HashMapNode<K, V>[]) new HashMapNode[4000];
		this.multiplier = multiplier;
		this.modulus = modulus;
		this.secondaryModulus = secondaryModulus;
		this.collisions = 0;
		this.probes = 0;
		this.maxProbes = 0;
	}
	
	// construct a DoubleHashMap with given capacity and given hash parameters
	@SuppressWarnings("unchecked")
	public DoubleHashMap(int hashMapSize, int multiplier, int modulus, int secondaryModulus)
	{
		this.array = (HashMapNode<K, V>[]) new HashMapNode[hashMapSize];
		this.multiplier = multiplier;
		this.modulus = modulus;
		this.secondaryModulus = secondaryModulus;
		this.collisions = 0;
		this.probes = 0;
		this.maxProbes = 0;
	}

	private int hashCode(K key)
	{
		return 0;
	}
	
	public int hash(K key)
	{
		return (this.multiplier * Math.abs(hashCode(key))) % this.modulus;
	}
	
	public int secondaryHash(K key)
	{
		return this.secondaryModulus - (Math.abs(hashCode(key)) % this.secondaryModulus);
	}
	
	//Return the number of nodes
	public int size()
	{
		int count = 0;
		for(HashMapNode<K, V> node : this.array)
		{
			if(node != null && node != this.SENTINEL)
			{
				count++;
			}
		}
		return count;
	}
	
	//Returns whether or not the hashmap is empty
	public boolean isEmpty()
	{
		return (this.size() == 0);
	}
	
	//Returns a list of keys
	public List<K> keys()
	{
		List<K> keys = new ArrayList<K>();
		for(HashMapNode<K, V> node : this.array)
		{
			if(node != null && node != this.SENTINEL)
			{
				keys.add(node.getKey());
			}
		}
		return keys;
	}
	
	//Inserts an element, returns the previous value stored in the key (if any)
	public V put(K key, V value)
	{
		int index = this.hashCode(key);
		int increment = this.secondaryHash(key);
		int i = index;
		int tries = 0;
		V result = null;
		do
		{
			if(this.array[i] == null || this.array[i] == this.SENTINEL)
			{
				this.array[i] = new HashMapNode<K, V>(key, value);
				break;
			}
			else if(this.array[i].getKey().equals(key))
			{
				result = this.array[i].getValue();
				this.array[i].setValue(value);
				break;
			}
			tries++;
			i = (i + increment) % this.array.length;
		}
		while(i != index);
		if(tries > this.maxProbes)
		{
			this.maxProbes = tries;
		}
		this.probes += tries;
		this.collisions += Integer.signum(tries);
		return result;
	}
	
	//Given a key, returns the node stored under it if it exists, else returns null
	private HashMapNode<K, V> find(K key)
	{
		int index = this.hashCode(key);
		int increment = this.secondaryHash(key);
		int i = index;
		do
		{
			if(this.array[i] == null)
			{
				return null;
			}
			if(this.array[i].getKey().equals(key))
			{
				return this.array[i];
			}
			i = (i + increment) % this.array.length;
		}
		while(i != index);
		return null;
	}
	
	//Returns a stored value given its key
	public V get(K key)
	{
		HashMapNode<K, V> node = this.find(key);
		if(node == null)
		{
			return null;
		}
		else
		{
			return node.getValue();
		}
	}
	
	//Removes a stored value and returns it, given its key
	public V remove(K key)
	{
		HashMapNode<K, V> node = this.find(key);
		if(node == null)
		{
			return null;
		}
		else
		{
			V result = node.getValue();
			node = this.SENTINEL;
			return result;
		}
	}
	
	// collision statistics
	public int putCollisions()
	{
		return this.collisions;
	}
	
	public int totalCollisions()
	{
		return this.probes;
	}
	
	public int maxCollisions()
	{
		return this.maxProbes;
	}
	
	public void resetStatistics()
	{
		this.collisions = 0;
		this.probes = 0;
		this.maxProbes = 0;
	}
}